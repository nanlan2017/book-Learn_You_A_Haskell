# 很经典

就是说： 
1. 由于柯里化，一切函数都已经变成了 单进单出 的函数。 就像一个管子 （其中穿过的 ，可能是任何可运算的东西，包括值和函数。）
2. 由于函数组合，管子是可以连接的。

---
现在要解决的问题：
1. 有些值是由上下文的（装在盒子中的），要让函数作用于它（让盒子能从函数管子中通过）。
   —————————— 能通过函数管子的那种 盒子 ，叫做 “函子” functor   （能被map over 的，就是 Functor)
   ———————— 这种盒子 开放了map 接口，能让函数直接作用于 盒子内的东西


2. 前面说了：通过管子的不光可能是值 （包括盒子中的值）， 还可能是 函数
   ###  盒子+值        盒子+函数
   ### (Just 4) <*> (Just (*3))  ————>  Just 12

   @ 如果函数也 处在了“盒子”中，（你的这截pipeline 是 盒子中的管子）
     这是来了一个 装有值的盒子，
     也要让他们双方都能越过盒子进行运算！！




****************************************************************************************************
         值            函数
有无盒子    无            无      直接运算
          有            无       fmap f (▇▇ val)   即    f <$> ▇▇ val   
                                 (▇▇ val) >>= f'
          无            有       ($ val) <$> (▇▇ f)                 
          有            有       (▇▇ f) <*> (▇▇ val)
                                  // (▇▇ f‘)   ？？？ 

  1.  对于返回含 Context 值的 f' 而言，如何让它 连续作用 （每作用一次就会套一层盒子 ，  只能用 >>=
  2.  我有一个含 context 的值 （▇▇ val），如何用一个函数作用于它：
        1. 若函数 f 无 context,
            a. 若函数f val 的返回值无context， 则用fmap      f <$> ▇▇ val
            b. 若函数f' val 的返回值有 Contxt, 则用bind     (▇▇ val) >>= f'                             
        2. 若函数(▇▇ f)有 context,
                                            则用ap       (▇▇ f) <*> (▇▇ val)      -- 默认 f val 不会返回context 值
                                            ？ 若 f val 返回context 值呢
      我有一个 raw 值 val, 如何用一个函数作用于它：
        1. 若函数无 Context, 则直接 作用 （可能返回带 context 的值）
        2. 若函数有 context, 
            a. 若函数f val 的返回值无context，则用fmap    ($ val) <$> (▇▇ f)
            b. 若函数f' val 的返回值有 Contxt, 则用bind    (return val)  >>= f'
   结论：
       -- ▇▇▇▇▇▇▇▇▇▇★ 会返回context 值的函数 是不能用ap 的， 也不能用fmap ———————— 因为这两个接口不带join塌缩，必然引起嵌套。                                         
      // 只要会出现 Context，最后结果也肯定有一层context
      // bind 是都可以的：大不了两边都 pure/return 一下（反正最后肯定有context)
         而fmap, ap 只能对应一种情况                                             

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#3. 盒子中可能包含盒子 


     ==============================================================

     ▇▇▇▇▇▇ 所谓 Functor,Applicative,Monad  都是指 盒子的性质。

     Functor 性质的盒子：     （里面装的是 值）    ——————  可以接受一个 函数 作用其上                   ———————— 运算结果是： 自身这种盒子（+值=运算结果）
     Applicative 性质的盒子： （里面装的是 函数）  ——————  可以接受一个 “盒子中的值”， 完成两个盒子的 碰撞~~———————— 运算结果是： 自身这种盒子（+值=运算结果）
     Monad 性质的盒子：        （里面装的是 值）   ——————  可以接受一个 “返回盒子的” 函数 （该函数是‘裸’的) ———————— 运算结果是： 函数返回的那种盒子 （+值=运算结果） 